# Регулярные выражения
---

>Регулярные выражения - это такие команды для сложного поиска и замены (или просто поиска) расположенных внутри слешей /.

1.  Точка обозначает любой символ:
```js
'xax eee'.replace(/x.x/, '!'); // вернет '! eee'
```  

2. Модификатор `g` включает режим глобального поиска и замены - без него регулярка ищет только первое совпадение, а с ним - все совпадения:
```js
'aab'.replace(/a/,  '!'); // вернет '!ab' без модификаторы g
'aab'.replace(/a/g, '!'); // вернет '!!b' с помощью модификатора g находит все совпадения
```

3. Операторы повторения символов в регулярках действуют на тот символ, который стоит перед ними:

		- плюс + (один и более раз)
		- звездочка * (ноль или более раз) 
		- вопрос ? (ноль или один раз)

```js
let str = 'xx xax xaax xaaax xbx';
let res = str.replace(/xa+x/g, '!');
//Результат:  'xx ! ! ! xbx'

let str = 'xx xax xaax xaaax xbx'
let res = str.replace(/xa*x/g, '!');
//Результат: '! ! ! ! xbx'

let str = 'xx xax xaax xbx';
let res = str.replace(/xa?x/g, '!');
//Результат: '! ! xaax xbx'
```

4. Группирующие скобки в регулярках. (Оператор после скобок, подействует на все что внутри скобок `(ab)+`)
```js
let str = 'xabx xababx xaabbx'
let res = str.replace(/x(ab)+x/g, '!');
//Результат: '! ! xaabbx'
```

5. Экранирование с помощью обратного слэша:
```js
let str = 'a+x ax aax aaax';
let res = str.replace(/a\+x/g, '!');
//Результат: '! ax aax aaax'
```

>Цифры нельзя экранировать.
>Являются спецсимволами: $ ^ . * + ? \ / {} [] () | все остальное экранировать нельзя

6. Фигурные скобки.

>Операторы '+', '*', '?' хороши, однако, с их помощью нельзя указать конкретное число повторений.

		- {5} - пять повторений
		- {2,5} – повторяется от двух до пяти (оба включительно)
		- {2,} - повторяется два и более раз
>Ноль тоже допустим.

```js
let str = 'xx xax xaax xaaax';
let res = str.replace(/xa{1,2}x/g, '!');
//Результат: 'xx ! ! xaaax'
```

7. Жадность в регулярных выражениях.

>Устанавливаем знак вопроса перед оператором: `+?`

Пример:
```js
let str = 'aeeex zzz x kkk';
let res = str.replace(/a.+x/g, '!');
// Результат '! kkk'  Получаем от самой первой `a` до самой последний `x`
// таким образом и захватывая еще `z`, а нам этого не надо.

// Чтобы ограничить жадность, нужно после оператора повторения поставить знак вопроса:
let res = str.replace(/a.+?x/g, '!');
//Результат '! zzz x kkk'
//Жадность можно ограничивать всем операторам повторения: и *, и ?, и {} - вот так: *?, ?? и {}?.
```

8. Группы символов

		- Команда \d означает цифру от 0 до 9.
		- Команда \w обозначает цифру, латинскую букву или знак подчеркивания
			(Кириллические символы не входят в группу \w.) Для их получения нужно
			использовать группу в квадратных скобках, вот так: [а-я].
			
		- Команда \s обозначает пробел или пробельный символ: пробел, перевод
			cтроки, табуляцию.
			
		- Можно инвертировать значение команды, написав большую букву: например, 
			если \d - цифра, то \D - не цифра.
			
		- Команда \W не цифра и не буква.
		- Команда \S не пробельный символ.

```js
let str = '1 12 123 abc @@@';
let res = str.replace(/\d+/g, '!');
//Результат: '! ! ! abc @@@'

let str = '123abc3@@';
let res = str.replace(/\D+/g, '!');
//Результат: '123!3!'

let str = '1 12 123 abc @@@';
let res = str.replace(/\S+/g, '!');
//Результат: '! ! ! ! !'
```

9. Наборы символов (Операция `или`).

>Группы символов \d и \w не очень гибкие. 
>Квадратные скобки заменяют собой один символ, любой из перечисленных внутри.
>
>/x[abc]+x/ - мы говорим, что внутри иксов может быть любое количество символов 'a', 'b' и 'c' - в любых комбинациях.
>
>Спецсимволы внутри [ ] становятся обычными символами, это значит, что их не надо экранировать обратным слешем.
>
>Если нам нужны квадратные скобки как символы внутри [ ] - то их нужно экранировать обратным слешем.
>
>Дефис - тоже спецсимвол внутри [ ] (а вот снаружи - нет).

```js
let str = 'xax xbx xcx x@x';
let res = str.replace(/x[a-z]x/g, '!');
//Результат: '! ! ! x@x'

let str = 'xax xBx xcx x5x x@x';
let res = str.replace(/x[a-zA-Z]x/g, '!');
//Результат: '! ! ! x5x x@x'

let str = 'xax xbx x1x x2x x3x';
let res = str.replace(/x[a-z12]x/g, '!'); 
//между иксами любая буква от 'a' до 'z' или цифры 1, 2
//Результат: '! ! ! ! x3x'

//В данном примере шаблон поиска выглядит так: между иксами любая цифра, либо буква от 'a' до 'f':
let str = 'xax xbx x1x x2x xhx x@x';
let res = str.replace(/x[\da-f]x/g, '!');
//Результат: '! ! ! ! xhx x@x'
```

10. Инвертирование наборов символов

>Команда `[ab]` ищет букву 'a' или 'b', то команда `[^ab]` будет искать все символы, кроме 'a' и 'b'.
>
>Чтобы получить шляпку как символ, нужно или заэкранировать ее, или убрать с первого места.

```js
let str = 'xaz xbz xcz xez';
let res = str.replace(/x[^abc]z/g, '!');
//Результат: 'xax xbx xcx !'

let str = 'xaz x1z xAz x.z x@z';
let res = str.replace(/x[^\d.a-z]z/g, '!');
//Результат: 'xaz x1z ! x.z !'

let str = 'axx bxx ^xx dxx';
let res = str.replace(/[d^]xx/g, '!');
//Результат: 'axx bxx ! !'
```

11. Начало и конец строки в регулярках.

>Существуют специальные символы, которые обозначают начало '^' или конец строки '$'. 

```js
//В данном примере шаблон поиска такой: заменить 'aaa' на '!' только, если оно стоит в начале строки:
let str = 'aaa aaa aaa';
let res = str.replace(/^aaa/g, '!');
//Результат: '! aaa aaa'


//В данном примере шаблон поиска такой: заменить 'aaa' на '!' только, если оно стоит в конце строки:
let str = 'aaa aaa aaa';
let res = str.replace(/aaa$/g, '!');
//Результат: 'aaa aaa !'


//Когда в начале регулярки стоит '^', а в конце - '$', то таким образом мы проверяем всю строку целиком на соответствие регулярке.
let str = 'aaa';
let res = str.replace(/^a+$/g, '!');
//Результат: '!'
```

12. Команда `или`

>Команда `|` более мощный вариант 'или' по сравнению с командой [ ].

```js
let str = 'aaa bbb ccc ddd';
let res = str.replace(/a+|b+|c+/g, '!');
//Результат: '! ! ! ddd'

let str = 'a ab abc 1 12 123';
let res = str.replace(/[a-z]+|\d{3}/g, '!');
//Результат: '! ! ! 1 12 !'

//Если вертикальная черта стоит внутри круглых скобок, то 'или' работает только внутри этих скобок.
let str = 'axx bxx bbxx exx';
let res = str.replace(/(a|b+)xx/g, '!');
//Результат: '! ! ! exx'
```

13. Метод test проверяет, есть ли в строке хотя бы одно совпадение с регуляркой.

```js
/a+/.test('eee aaa bbb'); // вернет true
/^a+$/.test('aaaaaaaaa'); // вернет true
```

14. Метод match с модификатором `g`

Давайте получим массив подстрок, состоящих из букв 'a':
```js
let str = 'a aa aaa aaaa';
let res = str.match(/a+/g, '!');
//Результат: ['a', 'aa', 'aaa', 'aaaa']
```



---

15. Карманы в методе match.

> Для того чтобы положить в карман нужно использовать круглые скобки.

```js
let str = 'sss xaaax zzz';
let res = str.match(/x(a+)x/);

console.log(res[0]); // выведет 'xaaax' - найденное
console.log(res[1]); // выведет 'aaa'   - карман


// несколько карманов
let str = 'sss xaaa-bbbx zzz';
let res = str.match(/x(a+)-(b+)x/);

console.log(res[0]); // выведет 'xaaax' - найденное
console.log(res[1]); // выведет 'aaa'   - 1 карман
console.log(res[2]); // выведет 'bbb'   - 2 карман
```

16. Карманы в методе replace.

>\$1 - первый карман, \$2 - второй карман и так далее.
>\$\& - всё найденное совпадение, \$\` и \$' -часть строки до и после совпадения.
>Чтобы \$\` не было воспринято как команда, доллар нужно удвоить:

Нужно поменять местами буквы до @ и после.
```js
let str = 'aaa@bbb ссс@ddd';
let res = str.replace(/([a-z]+)@([a-z]+)/g, '$2@$1');
//Результат: 'bbb@aaa ddd@ссс'

let str = 'aaa $ bbb';
let res = str.replace(/\$/g, '`$$`');
//Результат: 'aaa `$` bbb'
```

17. Карманы в самой регулярке.

>Первый карман будет доступен вот так: \1, второй карман вот так - \2, третий - \3 и так далее.

```js
let str = 'aa bb cd ef';
let res = str.replace(/([a-z])\1/g, '!');
//Результат: '! ! cd ef'

let str = 'asxca buzxb csgd';
let res = str.replace(/([a-z])[a-z]+\1/g, '!');
//Результат: '! ! csgd'
```

18. Несохраняющие скобки в регулярках.

>Скобки ( ) выполняют две функции - группировка символов и функцию кармана. 
>А что делать, если нам нужно сгруппировать, но в карман не класть?
>Для решения такой проблемы придуманы специальные несохраняющие скобки (?: ) - они группируют, но не кладут в карман.

19. Просмотр символов.

>Не следует заменять - делается это с помощью специальных скобок (?= ), которые просто смотрят, но не забирают с собой.
>`'aaax aaab'.replace(/aaa(?=x)/g, '!'); // вернет '!x aaab'`

>(?! ) - он, наоборот, говорит, что чего-то должно не быть
>`'aaax aaab'.replace(/aaa(?!x)/g, '!'); // вернет 'aaax !b'`

20. Коллбэк в методе replace в регулярках.

```js
let str = '2 3 4 5';
let result = str.replace(/\d+/g, function (match) {
	return match**2; 
});
console.log(result); // выведет '4 9 16 25'
```

21. Метод search.

```js
let str = 'a aa aaa aaaa aaaa';
let res = str.search(/aaa/);
//Результат: 5
```

22. Метод split он разбивает строку в массив по разделителю.

```js
let str = 'a-b+c-d+e';
let res = str.split(/[-+]/);
//Результат: ['a', 'b', 'c', 'd', 'e']
```